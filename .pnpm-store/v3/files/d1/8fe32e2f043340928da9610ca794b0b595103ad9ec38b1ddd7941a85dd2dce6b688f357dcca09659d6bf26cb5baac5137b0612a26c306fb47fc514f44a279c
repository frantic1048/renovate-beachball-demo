"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCliOptions = void 0;
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const workspace_tools_1 = require("workspace-tools");
const env_1 = require("../env");
// For camelCased options, yargs will automatically accept them with-dashes too.
const arrayOptions = ['disallowedChangeTypes', 'package', 'scope'];
const booleanOptions = [
    'all',
    'bump',
    'bumpDeps',
    'commit',
    'disallowDeletedChangeFiles',
    'fetch',
    'forceVersions',
    'gitTags',
    'help',
    'keepChangeFiles',
    'new',
    'publish',
    'push',
    'verbose',
    'version',
    'yes',
];
const numberOptions = ['depth', 'gitTimeout', 'retries', 'timeout'];
const stringOptions = [
    'access',
    'authType',
    'branch',
    'canaryName',
    'changehint',
    'configPath',
    'dependentChangeType',
    'fromRef',
    'message',
    'prereleasePrefix',
    'registry',
    'tag',
    'token',
    'type',
];
/** Type hack to verify that an array includes all keys of a type */
const allKeysOfType = () => (...x) => x;
// Verify that all the known CLI options have types specified, to ensure correct parsing.
//
// NOTE: If a prop is missing, this will have a somewhat misleading error:
//   Argument of type '"disallowedChangeTypes"' is not assignable to parameter of type '"tag" | "version"'
//
// To fix, add the missing names after "parameter of type" ("tag" and "version" in this example)
// to the appropriate array above.
const knownOptions = allKeysOfType()(...arrayOptions, ...booleanOptions, ...numberOptions, ...stringOptions, 
// these options are filled in below, not respected from the command line
'path', 'command');
const parserOptions = {
    configuration: {
        'boolean-negation': true,
        'camel-case-expansion': true,
        'dot-notation': false,
        'duplicate-arguments-array': true,
        'flatten-duplicate-arrays': true,
        'greedy-arrays': true,
        'parse-numbers': true,
        'parse-positional-numbers': false,
        'short-option-groups': false,
        'strip-aliased': true,
        'strip-dashed': true,
    },
    // spread to get rid of readonly...
    array: [...arrayOptions],
    boolean: [...booleanOptions],
    number: [...numberOptions],
    string: [...stringOptions],
    alias: {
        authType: ['a'],
        branch: ['b'],
        configPath: ['c', 'config'],
        forceVersions: ['force'],
        fromRef: ['since'],
        help: ['h', '?'],
        message: ['m'],
        package: ['p'],
        registry: ['r'],
        tag: ['t'],
        token: ['n'],
        version: ['v'],
        yes: ['y'],
    },
};
let cachedCliOptions;
function getCliOptions(argv, disableCache) {
    // Special case caching to process.argv which should be immutable
    if (argv === process.argv) {
        if (disableCache || env_1.env.beachballDisableCache || !cachedCliOptions) {
            cachedCliOptions = getCliOptionsUncached(process.argv);
        }
        return cachedCliOptions;
    }
    else {
        return getCliOptionsUncached(argv);
    }
}
exports.getCliOptions = getCliOptions;
function getCliOptionsUncached(argv) {
    // Be careful not to mutate the input argv
    const trimmedArgv = argv.slice(2);
    const args = (0, yargs_parser_1.default)(trimmedArgv, parserOptions);
    const { _: positionalArgs, ...options } = args;
    let cwd;
    try {
        cwd = (0, workspace_tools_1.findProjectRoot)(process.cwd());
    }
    catch (err) {
        cwd = process.cwd();
    }
    if (positionalArgs.length > 1) {
        throw new Error(`Only one positional argument (the command) is allowed. Received: ${positionalArgs.join(' ')}`);
    }
    const cliOptions = {
        ...options,
        command: positionalArgs.length ? String(positionalArgs[0]) : 'change',
        path: cwd,
    };
    if (args.branch) {
        // TODO: This logic assumes the first segment of any branch name with a slash must be the remote,
        // which is not necessarily accurate. Ideally we should check if a remote with that name exists,
        // and if not, perform the default remote lookup.
        cliOptions.branch =
            args.branch.indexOf('/') > -1
                ? args.branch
                : (0, workspace_tools_1.getDefaultRemoteBranch)({ branch: args.branch, verbose: args.verbose, cwd });
    }
    if (cliOptions.command === 'canary') {
        cliOptions.tag = cliOptions.canaryName || 'canary';
    }
    for (const key of Object.keys(cliOptions)) {
        const value = cliOptions[key];
        if (value === undefined) {
            delete cliOptions[key];
        }
        else if (typeof value === 'number' && isNaN(value)) {
            throw new Error(`Non-numeric value passed for numeric option "${key}"`);
        }
        else if (knownOptions.includes(key)) {
            if (Array.isArray(value) && !arrayOptions.includes(key)) {
                throw new Error(`Option "${key}" only accepts a single value. Received: ${value.join(' ')}`);
            }
        }
        else if (value === 'true') {
            // For unknown arguments like --foo=true or --bar=false, yargs will handle the value as a string.
            // Convert it to a boolean to avoid subtle bugs.
            cliOptions[key] = true;
        }
        else if (value === 'false') {
            cliOptions[key] = false;
        }
    }
    return cliOptions;
}
//# sourceMappingURL=getCliOptions.js.map