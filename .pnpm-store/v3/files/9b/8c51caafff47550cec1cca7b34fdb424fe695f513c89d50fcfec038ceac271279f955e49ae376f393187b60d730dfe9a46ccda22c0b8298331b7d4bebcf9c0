"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = void 0;
const isGitAvailable_1 = require("./isGitAvailable");
const workspace_tools_1 = require("workspace-tools");
const isValidAuthType_1 = require("./isValidAuthType");
const isValidChangeType_1 = require("./isValidChangeType");
const isChangeFileNeeded_1 = require("./isChangeFileNeeded");
const isValidGroupOptions_1 = require("./isValidGroupOptions");
const isValidChangelogOptions_1 = require("./isValidChangelogOptions");
const readChangeFiles_1 = require("../changefile/readChangeFiles");
const getPackageInfos_1 = require("../monorepo/getPackageInfos");
const getPackageGroups_1 = require("../monorepo/getPackageGroups");
const getDisallowedChangeTypes_1 = require("../changefile/getDisallowedChangeTypes");
const areChangeFilesDeleted_1 = require("./areChangeFilesDeleted");
const validatePackageDependencies_1 = require("../publish/validatePackageDependencies");
const gatherBumpInfo_1 = require("../bump/gatherBumpInfo");
const isValidDependentChangeType_1 = require("./isValidDependentChangeType");
const getPackagesToPublish_1 = require("../publish/getPackagesToPublish");
const env_1 = require("../env");
function validate(options, validateOptions) {
    const { allowMissingChangeFiles = false, allowFetching = true } = validateOptions || {};
    console.log('\nValidating options and change files...');
    // Run the validation checks in stages and wait to exit until the end of the stage.
    // This provides more potentially useful info the user rather than hiding errors.
    let hasError = false;
    const logValidationError = (message) => {
        console.error(`ERROR: ${message}`);
        hasError = true;
    };
    if (!(0, isGitAvailable_1.isGitAvailable)(options.path)) {
        logValidationError('Please make sure git is installed and initialize the repository with "git init"');
        process.exit(1);
    }
    const untracked = (0, workspace_tools_1.getUntrackedChanges)(options.path);
    if (untracked.length) {
        console.warn('WARN: There are untracked changes in your repository:\n' + untracked.join('\n- '));
        !env_1.env.isCI && console.warn('Changes in these files will not trigger a prompt for change descriptions');
    }
    const packageInfos = (0, getPackageInfos_1.getPackageInfos)(options.path);
    if (options.all && options.package) {
        logValidationError('Cannot specify both "all" and "package" options');
    }
    else if (typeof options.package === 'string' && !packageInfos[options.package]) {
        logValidationError(`package "${options.package}" was not found`);
    }
    else {
        const invalidPackages = Array.isArray(options.package)
            ? options.package.filter(pkg => !packageInfos[pkg])
            : undefined;
        if (invalidPackages?.length) {
            logValidationError(`package(s) ${invalidPackages.map(pkg => `"${pkg}"`).join(', ')} were not found`);
        }
    }
    if (options.authType && !(0, isValidAuthType_1.isValidAuthType)(options.authType)) {
        logValidationError(`authType "${options.authType}" is not valid`);
    }
    if (options.command === 'publish' && options.token !== undefined) {
        if (options.token === '') {
            logValidationError('token should not be an empty string. This usually indicates an incorrect variable name ' +
                'or forgetting to pass a secret into a workflow step.');
        }
        else if (options.token.startsWith('$') && options.authType !== 'password') {
            logValidationError(`token appears to be a variable reference: "${options.token}" -- please check your workflow configuration.`);
        }
    }
    if (options.dependentChangeType && !(0, isValidChangeType_1.isValidChangeType)(options.dependentChangeType)) {
        logValidationError(`dependentChangeType "${options.dependentChangeType}" is not valid`);
    }
    if (options.type && !(0, isValidChangeType_1.isValidChangeType)(options.type)) {
        logValidationError(`Change type "${options.type}" is not valid`);
    }
    if (options.changelog && !(0, isValidChangelogOptions_1.isValidChangelogOptions)(options.changelog)) {
        hasError = true; // the helper logs this
    }
    if (options.groups && !(0, isValidGroupOptions_1.isValidGroupOptions)(options.groups)) {
        hasError = true; // the helper logs this
    }
    // this exits the process if any package belongs to multiple groups
    const packageGroups = (0, getPackageGroups_1.getPackageGroups)(packageInfos, options.path, options.groups);
    if (options.groups && !(0, isValidGroupOptions_1.isValidGroupedPackageOptions)(packageInfos, packageGroups)) {
        hasError = true; // the helper logs this
    }
    if (hasError) {
        // If any of the above basic checks failed, it doesn't make sense to check if change files are needed
        process.exit(1);
    }
    let isChangeNeeded = false;
    if (allowFetching) {
        // This has the side effect of fetching, so call it even if !allowMissingChangeFiles for now
        isChangeNeeded = (0, isChangeFileNeeded_1.isChangeFileNeeded)(options, packageInfos);
        if (isChangeNeeded && !allowMissingChangeFiles) {
            logValidationError('Change files are needed!');
            console.log(options.changehint);
            process.exit(1); // exit here (this is the main poin)
        }
        if (options.disallowDeletedChangeFiles && (0, areChangeFilesDeleted_1.areChangeFilesDeleted)(options)) {
            logValidationError('Change files must not be deleted!');
            process.exit(1);
        }
    }
    const changeSet = (0, readChangeFiles_1.readChangeFiles)(options, packageInfos);
    for (const { changeFile, change } of changeSet) {
        const disallowedChangeTypes = (0, getDisallowedChangeTypes_1.getDisallowedChangeTypes)(change.packageName, packageInfos, packageGroups);
        if (!change.type) {
            logValidationError(`Change type is missing in ${changeFile}`);
            hasError = true;
        }
        else if (!(0, isValidChangeType_1.isValidChangeType)(change.type)) {
            logValidationError(`Invalid change type detected in ${changeFile}: "${change.type}"`);
            hasError = true;
        }
        else if (disallowedChangeTypes?.includes(change.type)) {
            logValidationError(`Disallowed change type detected in ${changeFile}: "${change.type}"`);
            hasError = true;
        }
        if (!change.dependentChangeType) {
            logValidationError(`dependentChangeType is missing in ${changeFile}`);
            hasError = true;
        }
        else if (!(0, isValidDependentChangeType_1.isValidDependentChangeType)(change.dependentChangeType, disallowedChangeTypes)) {
            logValidationError(`Invalid dependentChangeType detected in ${changeFile}: "${change.dependentChangeType}"`);
            hasError = true;
        }
    }
    if (!isChangeNeeded) {
        console.log('\nValidating package dependencies...');
        // TODO: It would be preferable if this could be done without getting the full bump info,
        // or at least if the bump info could be passed back out to other methods which currently
        // duplicate the calculation (it can be expensive, especially in large repos).
        const bumpInfo = (0, gatherBumpInfo_1.gatherBumpInfo)(options, packageInfos);
        const packagesToPublish = (0, getPackagesToPublish_1.getPackagesToPublish)(bumpInfo, true /*validationMode*/);
        if (!(0, validatePackageDependencies_1.validatePackageDependencies)(packagesToPublish, bumpInfo.packageInfos)) {
            logValidationError(`One or more published packages depend on an unpublished package!

Consider one of the following solutions:
- If the unpublished package should be published, remove \`"private": true\` from its package.json.
- If it should NOT be published, verify that it is only listed under devDependencies of published packages.
`);
            process.exit(1);
        }
    }
    console.log();
    return {
        isChangeNeeded,
    };
}
exports.validate = validate;
//# sourceMappingURL=validate.js.map