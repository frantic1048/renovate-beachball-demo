"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readChangeFiles = void 0;
const paths_1 = require("../paths");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const getScopedPackages_1 = require("../monorepo/getScopedPackages");
const workspace_tools_1 = require("workspace-tools");
/**
 * Read change files, excluding any changes for packages that are:
 * - out of scope (as defined in `options.scope`)
 * - private
 * - nonexistent
 *
 * The changes will also be transformed if `options.transform.changeFiles` is provided.
 *
 * Changes from grouped change files will be flattened into individual entries in the returned array
 * (so it's possible that multiple entries will have the same filename).
 */
function readChangeFiles(options, packageInfos) {
    const { path: cwd, fromRef } = options;
    const scopedPackages = (0, getScopedPackages_1.getScopedPackages)(options, packageInfos);
    const changePath = (0, paths_1.getChangePath)(cwd);
    if (!fs_extra_1.default.existsSync(changePath)) {
        return [];
    }
    const allChangeFiles = fs_extra_1.default.readdirSync(changePath);
    let filteredChangeFiles = allChangeFiles;
    if (fromRef) {
        const changeFilesSinceFromRef = (0, workspace_tools_1.getChangesBetweenRefs)(fromRef, 'HEAD', [
            '--diff-filter=d',
            '--relative', // results will include path relative to the cwd, i.e. only file names.
        ], '*.json', changePath);
        filteredChangeFiles = allChangeFiles.filter(fileName => changeFilesSinceFromRef?.includes(fileName));
    }
    try {
        // sort the change files by modified time. Most recent modified file comes first.
        filteredChangeFiles.sort((f1, f2) => fs_extra_1.default.statSync(path_1.default.join(changePath, f2)).mtime.getTime() - fs_extra_1.default.statSync(path_1.default.join(changePath, f1)).mtime.getTime());
    }
    catch (err) {
        console.warn('Failed to sort change files', err);
    }
    const changeSet = [];
    // Read, transform, and filter the change files
    for (const changeFile of filteredChangeFiles) {
        const changeFilePath = path_1.default.join(changePath, changeFile);
        let changeInfo;
        try {
            changeInfo = fs_extra_1.default.readJSONSync(changeFilePath);
        }
        catch (e) {
            console.warn(`Error reading or parsing change file ${changeFilePath}: ${e}`);
            continue;
        }
        // Transform the change files, if the option is provided
        if (options.transform?.changeFiles) {
            try {
                changeInfo = options.transform?.changeFiles(changeInfo, changeFilePath);
            }
            catch (e) {
                console.warn(`Error transforming ${changeFilePath}: ${e}`);
                continue;
            }
        }
        const changes = changeInfo.changes || [changeInfo];
        // Filter the changes from this file
        for (const change of changes) {
            // Log warnings about change entries for nonexistent and private packages.
            // (This may happen if a package is renamed or its private flag is changed.)
            const warningType = !packageInfos[change.packageName]
                ? 'nonexistent'
                : packageInfos[change.packageName].private
                    ? 'private'
                    : undefined;
            if (warningType) {
                const resolution = options.groupChanges ? 'remove the entry from this file' : 'delete this file';
                console.warn(`Change detected for ${warningType} package ${change.packageName}; ${resolution}: "${path_1.default.resolve(changePath, changeFile)}"`);
            }
            // Add the change to the final list if it's valid and in scope
            if (!warningType && scopedPackages.includes(change.packageName)) {
                changeSet.push({ changeFile, change });
            }
        }
    }
    return changeSet;
}
exports.readChangeFiles = readChangeFiles;
//# sourceMappingURL=readChangeFiles.js.map