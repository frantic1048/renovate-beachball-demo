"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toposortPackages = void 0;
const toposort_1 = __importDefault(require("toposort"));
/**
 * Topologically sort the packages based on their dependency graph.
 * Dependency comes first before dependent.
 * @param packages Packages to be sorted.
 * @param packageInfos PackagesInfos for the sorted packages.
 */
function toposortPackages(packages, packageInfos) {
    const packageSet = new Set(packages);
    const dependencyGraph = [];
    for (const pkgName of packageSet) {
        const info = packageInfos[pkgName];
        if (!info) {
            throw new Error(`Package info is missing for ${pkgName}.`);
        }
        const allDeps = new Set([info.dependencies, info.devDependencies, info.peerDependencies]
            .flatMap(deps => Object.keys(deps || {}))
            .filter(pkg => packageSet.has(pkg)));
        if (allDeps.size) {
            for (const depPkgName of allDeps) {
                dependencyGraph.push([depPkgName, pkgName]);
            }
        }
        else {
            dependencyGraph.push([undefined, pkgName]);
        }
    }
    try {
        return (0, toposort_1.default)(dependencyGraph).filter((pkg) => !!pkg);
    }
    catch (err) {
        throw new Error(`Failed to topologically sort packages: ${err?.message}`);
    }
}
exports.toposortPackages = toposortPackages;
//# sourceMappingURL=toposortPackages.js.map