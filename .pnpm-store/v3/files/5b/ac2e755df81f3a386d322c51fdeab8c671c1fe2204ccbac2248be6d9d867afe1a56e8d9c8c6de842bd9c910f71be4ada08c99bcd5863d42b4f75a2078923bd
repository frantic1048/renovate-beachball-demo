"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeChangelog = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const getPackageChangelogs_1 = require("./getPackageChangelogs");
const renderChangelog_1 = require("./renderChangelog");
const renderJsonChangelog_1 = require("./renderJsonChangelog");
const isPathIncluded_1 = require("../monorepo/isPathIncluded");
const mergeChangelogs_1 = require("./mergeChangelogs");
async function writeChangelog(options, changeFileChangeInfos, calculatedChangeTypes, dependentChangedBy, packageInfos) {
    const groupedChangelogPaths = await writeGroupedChangelog(options, changeFileChangeInfos, calculatedChangeTypes, packageInfos);
    const groupedChangelogPathSet = new Set(groupedChangelogPaths);
    const changelogs = (0, getPackageChangelogs_1.getPackageChangelogs)({
        changeFileChangeInfos,
        calculatedChangeTypes,
        dependentChangedBy,
        packageInfos,
        cwd: options.path,
    });
    // Use a standard for loop here to prevent potentially firing off multiple network requests at once
    // (in case any custom renderers have network requests)
    for (const pkg of Object.keys(changelogs)) {
        const packagePath = path_1.default.dirname(packageInfos[pkg].packageJsonPath);
        if (groupedChangelogPathSet?.has(packagePath)) {
            console.log(`Changelog for ${pkg} has been written as a group here: ${packagePath}`);
        }
        else {
            await writeChangelogFiles(options, changelogs[pkg], packagePath, false);
        }
    }
}
exports.writeChangelog = writeChangelog;
async function writeGroupedChangelog(options, changeFileChangeInfos, calculatedChangeTypes, packageInfos) {
    if (!options.changelog) {
        return [];
    }
    const { groups: changelogGroups } = options.changelog;
    if (!changelogGroups?.length) {
        return [];
    }
    // Grouped changelogs should not contain dependency bump entries
    const changelogs = (0, getPackageChangelogs_1.getPackageChangelogs)({
        changeFileChangeInfos,
        calculatedChangeTypes,
        packageInfos,
        cwd: options.path,
    });
    const groupedChangelogs = {};
    for (const pkg of Object.keys(changelogs)) {
        const packagePath = path_1.default.dirname(packageInfos[pkg].packageJsonPath);
        const relativePath = path_1.default.relative(options.path, packagePath);
        for (const group of changelogGroups) {
            const { changelogPath, masterPackageName } = group;
            const masterPackage = packageInfos[masterPackageName];
            if (!masterPackage) {
                console.warn(`master package ${masterPackageName} does not exist.`);
                continue;
            }
            if (!fs_extra_1.default.existsSync(changelogPath)) {
                console.warn(`changelog path ${changelogPath} does not exist.`);
                continue;
            }
            const isInGroup = (0, isPathIncluded_1.isPathIncluded)(relativePath, group.include, group.exclude);
            if (isInGroup) {
                groupedChangelogs[changelogPath] ?? (groupedChangelogs[changelogPath] = {
                    changelogs: [],
                    masterPackage,
                });
                groupedChangelogs[changelogPath].changelogs.push(changelogs[pkg]);
            }
        }
    }
    const changelogAbsolutePaths = [];
    for (const changelogPath in groupedChangelogs) {
        const { masterPackage, changelogs } = groupedChangelogs[changelogPath];
        const groupedChangelog = (0, mergeChangelogs_1.mergeChangelogs)(changelogs, masterPackage);
        if (groupedChangelog) {
            await writeChangelogFiles(options, groupedChangelog, changelogPath, true);
            changelogAbsolutePaths.push(path_1.default.resolve(changelogPath));
        }
    }
    return changelogAbsolutePaths;
}
async function writeChangelogFiles(options, newVersionChangelog, changelogPath, isGrouped) {
    let previousJson;
    // Update CHANGELOG.json
    const changelogJsonFile = path_1.default.join(changelogPath, 'CHANGELOG.json');
    try {
        previousJson = fs_extra_1.default.existsSync(changelogJsonFile) ? fs_extra_1.default.readJSONSync(changelogJsonFile) : undefined;
    }
    catch (e) {
        console.warn(`${changelogJsonFile} is invalid: ${e}`);
    }
    try {
        const nextJson = (0, renderJsonChangelog_1.renderJsonChangelog)(newVersionChangelog, previousJson);
        fs_extra_1.default.writeJSONSync(changelogJsonFile, nextJson, { spaces: 2 });
    }
    catch (e) {
        console.warn(`Problem writing to ${changelogJsonFile}: ${e}`);
    }
    // Update CHANGELOG.md
    if (newVersionChangelog.comments.major ||
        newVersionChangelog.comments.minor ||
        newVersionChangelog.comments.patch ||
        newVersionChangelog.comments.prerelease) {
        const changelogFile = path_1.default.join(changelogPath, 'CHANGELOG.md');
        const previousContent = fs_extra_1.default.existsSync(changelogFile) ? fs_extra_1.default.readFileSync(changelogFile).toString() : '';
        const newChangelog = await (0, renderChangelog_1.renderChangelog)({
            previousJson,
            previousContent,
            newVersionChangelog,
            isGrouped,
            changelogOptions: options.changelog || {},
        });
        fs_extra_1.default.writeFileSync(changelogFile, newChangelog);
    }
}
//# sourceMappingURL=writeChangelog.js.map