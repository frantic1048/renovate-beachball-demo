"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageChangelogs = void 0;
const path_1 = __importDefault(require("path"));
const generateTag_1 = require("../git/generateTag");
const paths_1 = require("../paths");
const workspace_tools_1 = require("workspace-tools");
/**
 * Used for `ChangelogEntry.commit` if the commit hash is not available.
 */
const commitNotAvailable = 'not available';
/**
 * Get the preliminary changelog info for each modified package, based on change files and dependent bumps.
 * @returns Mapping from package name to package changelog.
 */
function getPackageChangelogs(params) {
    var _a, _b, _c, _d;
    const { changeFileChangeInfos, calculatedChangeTypes, dependentChangedBy = {}, packageInfos, cwd } = params;
    const changelogs = {};
    const changeFileCommits = {};
    const changePath = (0, paths_1.getChangePath)(cwd);
    for (const { change, changeFile } of changeFileChangeInfos) {
        const { packageName, type: changeType, dependentChangeType, email, ...rest } = change;
        changelogs[packageName] ?? (changelogs[packageName] = createPackageChangelog(packageInfos[packageName]));
        changeFileCommits[changeFile] ?? (changeFileCommits[changeFile] = (0, workspace_tools_1.getFileAddedHash)(path_1.default.join(changePath, changeFile), cwd) || commitNotAvailable);
        (_a = changelogs[packageName]).comments ?? (_a.comments = {});
        (_b = changelogs[packageName].comments)[changeType] ?? (_b[changeType] = []);
        changelogs[packageName].comments[changeType].push({
            author: change.email,
            package: packageName,
            commit: changeFileCommits[changeFile],
            // This contains the comment and any extra properties added to the change file by
            // RepoOptions.changeFilePrompt.changePrompt
            ...rest,
        });
    }
    for (const [dependent, changedBy] of Object.entries(dependentChangedBy)) {
        if (packageInfos[dependent].private === true) {
            // Avoid creation of change log files for private packages since the version is
            // not managed by beachball and the log would only contain bumps to dependencies.
            continue;
        }
        changelogs[dependent] ?? (changelogs[dependent] = createPackageChangelog(packageInfos[dependent]));
        const changeType = calculatedChangeTypes[dependent];
        (_c = changelogs[dependent]).comments ?? (_c.comments = {});
        (_d = changelogs[dependent].comments)[changeType] ?? (_d[changeType] = []);
        for (const dep of changedBy) {
            if (dep !== dependent) {
                changelogs[dependent].comments[changeType].push({
                    author: 'beachball',
                    package: dependent,
                    comment: `Bump ${dep} to v${packageInfos[dep].version}`,
                    // This change will be made in the commit that is currently being created, so unless we
                    // split publishing into two commits (one for bumps and one for changelog updates),
                    // there's no way to know the hash yet. It's better to record nothing than incorrect info.
                    // https://github.com/microsoft/beachball/issues/901
                    commit: commitNotAvailable,
                });
            }
        }
    }
    return changelogs;
}
exports.getPackageChangelogs = getPackageChangelogs;
function createPackageChangelog(packageInfo) {
    const name = packageInfo.name;
    const version = packageInfo.version;
    return {
        name,
        version,
        tag: (0, generateTag_1.generateTag)(name, version),
        date: new Date(),
        comments: {},
    };
}
//# sourceMappingURL=getPackageChangelogs.js.map