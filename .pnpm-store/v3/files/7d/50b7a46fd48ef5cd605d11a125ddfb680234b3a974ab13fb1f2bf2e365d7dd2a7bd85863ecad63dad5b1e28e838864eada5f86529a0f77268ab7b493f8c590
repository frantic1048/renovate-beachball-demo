"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bumpInPlace = void 0;
const setDependentsInBumpInfo_1 = require("./setDependentsInBumpInfo");
const updateRelatedChangeType_1 = require("./updateRelatedChangeType");
const bumpPackageInfoVersion_1 = require("./bumpPackageInfoVersion");
const setGroupsInBumpInfo_1 = require("./setGroupsInBumpInfo");
const setDependentVersions_1 = require("./setDependentVersions");
/**
 * Updates BumpInfo according to change types, bump deps, and version groups
 *
 * NOTE: THIS FUNCTION MUTATES STATE!
 */
function bumpInPlace(bumpInfo, options) {
    const { bumpDeps } = options;
    const { packageInfos, scopedPackages, calculatedChangeTypes, changeFileChangeInfos, modifiedPackages } = bumpInfo;
    // pass 1: figure out all the change types for all the packages taking into account the bumpDeps option and version groups
    if (bumpDeps) {
        (0, setDependentsInBumpInfo_1.setDependentsInBumpInfo)(bumpInfo);
    }
    (0, setGroupsInBumpInfo_1.setGroupsInBumpInfo)(bumpInfo, options);
    // TODO: when we do "locked", or "lock step" versioning, we could simply skip setting grouped change types
    //       - set the version for all packages in the group in (bumpPackageInfoVersion())
    //       - the main concern is how to capture the bump reason in grouped changelog
    // pass 2: initialize grouped calculatedChangeTypes together
    for (const { change: changeInfo } of changeFileChangeInfos) {
        const groupName = Object.keys(bumpInfo.packageGroups).find(group => bumpInfo.packageGroups[group].packageNames.includes(changeInfo.packageName));
        if (groupName) {
            for (const packageNameInGroup of bumpInfo.packageGroups[groupName].packageNames) {
                calculatedChangeTypes[packageNameInGroup] = changeInfo.type;
            }
        }
    }
    for (const { changeFile } of changeFileChangeInfos) {
        (0, updateRelatedChangeType_1.updateRelatedChangeType)(changeFile, bumpInfo, bumpDeps);
    }
    // pass 3: actually bump the packages in the bumpInfo in memory (no disk writes at this point)
    Object.keys(calculatedChangeTypes).forEach(pkgName => {
        (0, bumpPackageInfoVersion_1.bumpPackageInfoVersion)(pkgName, bumpInfo, options);
    });
    // step 4: Bump all the dependencies packages
    bumpInfo.dependentChangedBy = (0, setDependentVersions_1.setDependentVersions)(packageInfos, scopedPackages, options);
    Object.keys(bumpInfo.dependentChangedBy).forEach(pkg => modifiedPackages.add(pkg));
}
exports.bumpInPlace = bumpInPlace;
//# sourceMappingURL=bumpInPlace.js.map