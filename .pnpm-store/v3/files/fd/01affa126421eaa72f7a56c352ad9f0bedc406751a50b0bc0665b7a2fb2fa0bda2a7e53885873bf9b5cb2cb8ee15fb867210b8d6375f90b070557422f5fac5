"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishToRegistry = void 0;
const lodash_1 = __importDefault(require("lodash"));
const performBump_1 = require("../bump/performBump");
const packagePublish_1 = require("../packageManager/packagePublish");
const validatePackageVersions_1 = require("./validatePackageVersions");
const displayManualRecovery_1 = require("./displayManualRecovery");
const validatePackageDependencies_1 = require("./validatePackageDependencies");
const performPublishOverrides_1 = require("./performPublishOverrides");
const getPackagesToPublish_1 = require("./getPackagesToPublish");
const callHook_1 = require("../bump/callHook");
/**
 * Publish all the bumped packages to the registry.
 */
async function publishToRegistry(originalBumpInfo, options) {
    const bumpInfo = lodash_1.default.cloneDeep(originalBumpInfo);
    if (options.bump) {
        await (0, performBump_1.performBump)(bumpInfo, options);
    }
    // get the packages to publish, reducing the set by packages that don't need publishing
    const packagesToPublish = (0, getPackagesToPublish_1.getPackagesToPublish)(bumpInfo);
    let invalid = false;
    if (!(await (0, validatePackageVersions_1.validatePackageVersions)(packagesToPublish, bumpInfo.packageInfos, options))) {
        (0, displayManualRecovery_1.displayManualRecovery)(bumpInfo);
        invalid = true;
    }
    else if (!(0, validatePackageDependencies_1.validatePackageDependencies)(packagesToPublish, bumpInfo.packageInfos)) {
        invalid = true;
    }
    if (invalid) {
        console.error('No packages were published due to validation errors (see above for details).');
        process.exit(1);
    }
    // performing publishConfig and workspace version overrides requires this procedure to ONLY be run right before npm publish, but NOT in the git push
    (0, performPublishOverrides_1.performPublishOverrides)(packagesToPublish, bumpInfo.packageInfos);
    // if there is a prepublish hook perform a prepublish pass, calling the routine on each package
    await (0, callHook_1.callHook)(options.hooks?.prepublish, packagesToPublish, bumpInfo.packageInfos);
    // finally pass through doing the actual npm publish command
    const succeededPackages = new Set();
    for (const pkg of packagesToPublish) {
        const result = await (0, packagePublish_1.packagePublish)(bumpInfo.packageInfos[pkg], options);
        if (result.success) {
            succeededPackages.add(pkg);
        }
        else {
            (0, displayManualRecovery_1.displayManualRecovery)(bumpInfo, succeededPackages);
            throw new Error('Error publishing! Refer to the previous logs for recovery instructions.');
        }
    }
    // if there is a postpublish hook perform a postpublish pass, calling the routine on each package
    await (0, callHook_1.callHook)(options.hooks?.postpublish, packagesToPublish, bumpInfo.packageInfos);
}
exports.publishToRegistry = publishToRegistry;
//# sourceMappingURL=publishToRegistry.js.map