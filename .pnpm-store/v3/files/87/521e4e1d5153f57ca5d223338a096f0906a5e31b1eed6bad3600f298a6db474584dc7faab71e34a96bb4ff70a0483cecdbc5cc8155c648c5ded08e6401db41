"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publish = void 0;
const gatherBumpInfo_1 = require("../bump/gatherBumpInfo");
const workspace_tools_1 = require("workspace-tools");
const prompts_1 = __importDefault(require("prompts"));
const readChangeFiles_1 = require("../changefile/readChangeFiles");
const bumpAndPush_1 = require("../publish/bumpAndPush");
const publishToRegistry_1 = require("../publish/publishToRegistry");
const getNewPackages_1 = require("../publish/getNewPackages");
const getPackageInfos_1 = require("../monorepo/getPackageInfos");
async function publish(options) {
    console.log('\nPreparing to publish');
    const { path: cwd, branch, registry, tag } = options;
    // First, validate that we have changes to publish
    const oldPackageInfos = (0, getPackageInfos_1.getPackageInfos)(cwd);
    const changes = (0, readChangeFiles_1.readChangeFiles)(options, oldPackageInfos);
    if (!changes.length) {
        console.log('Nothing to bump, skipping publish!');
        return;
    }
    // Collate the changes per package
    const currentBranch = (0, workspace_tools_1.getBranchName)(cwd);
    const currentHash = (0, workspace_tools_1.getCurrentHash)(cwd);
    console.log(`\nPublishing with the following configuration:

  registry: ${registry}

  current branch: ${currentBranch}
  current hash: ${currentHash}
  target branch: ${branch}
  tag: ${tag}

  bumps versions: ${options.bump ? 'yes' : 'no'}
  publishes to npm registry: ${options.publish ? 'yes' : 'no'}
  pushes to remote git repo: ${options.bump && options.push && options.branch ? 'yes' : 'no'}

`);
    if (!options.yes) {
        const response = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'yes',
            message: 'Is everything correct (use the --yes or -y arg to skip this prompt)?',
        });
        if (!response.yes) {
            return;
        }
    }
    // checkout publish branch
    const publishBranch = 'publish_' + String(new Date().getTime());
    console.log(`Creating temporary publish branch ${publishBranch}`);
    (0, workspace_tools_1.gitFailFast)(['checkout', '-b', publishBranch], { cwd });
    console.log(`\nGathering info ${options.bump ? 'to bump versions' : 'about versions and changes'}`);
    const bumpInfo = (0, gatherBumpInfo_1.gatherBumpInfo)(options, oldPackageInfos);
    if (options.new) {
        // Publish newly created packages even if they don't have change files
        // (this is unlikely unless the packages were pushed without a PR that runs "beachball check")
        bumpInfo.newPackages = new Set(await (0, getNewPackages_1.getNewPackages)(bumpInfo, options));
    }
    // Step 1. Bump + npm publish
    // npm / yarn publish
    if (options.publish) {
        console.log('\nBumping versions and publishing to npm');
        await (0, publishToRegistry_1.publishToRegistry)(bumpInfo, options);
        console.log();
    }
    else {
        console.log('Skipping publish');
    }
    // Step 2.
    // - reset, fetch latest from origin/master (to ensure less chance of conflict), then bump again + commit
    if (options.bump && branch && options.push) {
        // this does its own section logging
        await (0, bumpAndPush_1.bumpAndPush)(bumpInfo, publishBranch, options);
    }
    else {
        console.log('Skipping git push and tagging');
    }
    // Step 3.
    // Clean up: switch back to current branch, delete publish branch
    console.log('\nCleaning up');
    const revParseSuccessful = currentBranch || currentHash;
    if (currentBranch && currentBranch !== 'HEAD') {
        console.log(`git checkout ${currentBranch}`);
        (0, workspace_tools_1.gitFailFast)(['checkout', currentBranch], { cwd });
    }
    else if (currentHash) {
        console.log(`Looks like the repo was detached from a branch`);
        console.log(`git checkout ${currentHash}`);
        (0, workspace_tools_1.gitFailFast)(['checkout', currentHash], { cwd });
    }
    if (revParseSuccessful) {
        console.log(`deleting temporary publish branch ${publishBranch}`);
        const deletionResult = (0, workspace_tools_1.git)(['branch', '-D', publishBranch], { cwd });
        if (!deletionResult.success) {
            console.warn(`[WARN]: deletion of publish branch ${publishBranch} has failed!\n${deletionResult.stderr}`);
        }
    }
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map